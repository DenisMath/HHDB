\documentclass[a4paper,11pt]{article}

\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage[russian,english]{babel}
\usepackage{amssymb,upref}
\usepackage{amsmath,amsthm}
\usepackage{multicol}
\usepackage{geometry}
\usepackage[dvips]{graphicx}

\setcounter{MaxMatrixCols}{10}

\newtheorem{theorem}{Теорема}[subsection]
\newtheorem{lemma}{Лемма}[subsection]
\newtheorem{corollary}{Следствие}[subsection]
\newtheorem{remark}{Замечание}[subsection]
\newtheorem{definition}{Определение}[subsection]
\newtheorem{example}{Пример}[subsection]
\newtheorem{hyp}{Гипотеза}[subsection]
\newtheorem{question}{Вопрос}[subsection]

\begin{document}
\thispagestyle{plain}

Создание математической модели модуля Оракул.
\section{Постановка задачи}
Мужчина не пьет пиво - не предлагать ему пиво в контекстной рекламе.

Пример группировки (под группировкой видимо понимается построение сложных связей):
\begin{example}
В близкие моменты времени зафиксирован выход девайсов A,B,C с одного IP. В этом множестве девайсов возникла (пока слабая) связь. Данная связь усиливается с каждой  фиксацией совместного выхода с одного IP.
\end{example}
time\_stamp - 100\%

device\_id - 50\%

IP - 100\%

location - 30\%
\section {Данные для построения}
Нормализированная база данных логов.
\subsection {Входные данные}
Набор значений параметров - возраст, доход, образование и т.д.
\subsection {Выходные данные}
Набор IP и(или) device\_id
\section {Параметризация модуля}
Параметризация модуля связана с входными параметрами - возраст, доход, образование и т.д.
\section{Плагин}
Плагин расширения набора ip и id. На входе - набор ip и id, на выходе - расширенный набор ip и id возможно с действительным параметром. 
\section{Комментарии}
1. По сути задача состоит в предсказании ip и id рекламной компании. Использование обучения модуля путем параметризации представляется проблематичным. Дело в том, что непрерывность такого модуля, как функции врядли может иметь место, поскольку множество определения такой функции имеет сложную, предположительно фрактальную структуру.

% In fact the problem is the prediction of ip and id of advertising company. Using the training of module by means of parameterization is problematic. The fact that the continuity of such a module as a function can scarcely be the case as the set of definitions of this function is complex, presumably fractal structure.

2. Рекламное агенство предоставляет список услуг по распространению рекламы в интернете. По логам результатов рекламной компании модуль предоставляет совет по оптимальному заказу рекламы в данном агенстве для следующей такой же рекламной компании

% Advertising agency services list of dissemination of advertising on the Internet. According to logs of the results of the advertising company module provides  advice on the best advertising order in this agency for the next the same advertising company

3. Запускается небольшая рекламная компания. По ее результатам (логам) рекомендуется аудитория(список ip?) для проведения большой рекламной компании.

\section{Группировка}
Формализация - группировкою является функция $Group$, принимающая на входе множество логов $A$, фиксированный лог $a$ и возвращающая множество логов $B$, соответсвующих данному логу $a$.
$$ A, B \subset Logs, a \in Logs, Group(A,a) = B$$

 Возможна группировка по метрике $\rho$, заданной на множестве логов. При такой группировке функция $Group$ возвращает шар некоторого радиуса с центром в точке $a$.  Группировка подобного типа допускает прозрачную параметризацию. Параметр может быть привязан к радиусу возвращаемого шара. 
$$ A, B \subset Logs, a \in Logs, \rho :Logs\times Logs \rightarrow \mathbb{R}^+$$
$$ Group_{\rho}:2^{Logs}\times Logs \times \mathbb{R}^+ \rightarrow 2^{Logs}  $$
$$Group_{\rho}(A,a,t) = B_{\rho}(a,t)=B$$

\begin{question}
Каким образом конструируется непротиворечивая метрика на логах с возможно не заполненными полями?
\end{question}

Пример метрической группировки:
\begin{example}
\end{example}

Пример группировки по IP-связям:
\begin{example}
Проходим все пары девайсов(логов) во временных промежутках. Если два девайса заходили с одного IP(в двух логах одинаковый IP) в течении близкого промежутка времени, то вес между ними увеличивается на 1.

Данная модель содержит шум. Если известна периодичность смены IP адресов, то шум можно свести к нулю. Кроме того шум можно уменьшить с помощью корректирующего множителя - для пар, более далеким по времени, вес увеличивать с меньшим коеффициентом:
$$link(x,y) = \sum_{\{t \mid t = |x.time - y.time| \}} f(t)$$
\end{example}

\section{Формализация проблемы}
Базовыми сущностями положим множество логов. Мотивация для рассмотрения именно такого базового множества, а не множества девайсов  состоит в начальной неопределенности данного множества, а, следовательно, усложнение модели формалистикой теории нечетких множеств. Правильная же группировка множества логов позволяет в некоторых случаях получить $device\_id$  при помощи анализа косвенных данных, предоставляемых множеством логов методами коллаборативной фильтрации.
Введем группировку на множестве логов.

Каждый лог связан с некоторым местом( географическими координатами). Место не всегда фиксируется.

 Зададим на множестве логов функцию со следующеей спецификацией ( LLW - Logs' Links Weight ):
$$koord\_LLW : Logs \times Logs \rightarrow \mathbb{R}$$
Данная функция возвращает коэффициент связи между двумя логами по близости географических координат. При высоком коэффициенте связи логи предположительно близки по координатам.
Группировка при помощи данной функции предоставляет возможность для разбиения множества логов на кластеры, которые далее могут быть использованы  для коллаборативной фильтрации множества логов с условием близости географического положения места захвата логов. Один из возможных алгоритмов кластеризации:
\begin{example}
Фиксируется некоторое базовое множество логов, задающих кластеры. Например базовое множество можно определить, как множество логов с известными координатами, расположенными относительно далеко друг от друга (например близким к административным центрам ). Каждая точка(лог) относится к кластеру, который порожден базовой точкой с наибольшей связью для данной точки, в сравнении с другими базовыми точками. Должно быть определено правило соотношения точки с кластером в случае конфликтов( одинаковая коэффициент  связи с несколькими базовыми точками).
\end{example}

 Зададим на множестве логов функцию со следующеей спецификацией:
$$hh\_LLW : Logs \times Logs \rightarrow \mathbb{R}$$
Данная функция возвращает коэффициент связи между двумя логами по принадлежности к одному $household\_id$.

\begin{remark}
Очевидно кластеризация, полученная при помощи функции $hh\_LLW$, должна быть близка к некоторому разбиение кластеризации, полученной при помощи функции $koord\_LLW$. То есть последовательное использование данных двух функций задает некоторую 2-уровневую классификацию на множестве логов. Однако использование различных подходов при реализации данных функций может привести к существенному отклонению от данного правила.
\end{remark}


\subsection{Построение функции $koord\_LLW$}
\subsection{Построение функции $hh\_LLW$}


\section{Механизм рекламной компании}
SSP отправляет пакеты логов на биржу. DSP оценивают каждый лог по релевантности логов для рекламной компании и предлагают цену за рекламу для него. Модуль предлагает карту релевантности логов для рекламной кампании. 

\section{Используемые методы}
\subsection{Коллаборативная фильтрация}
\begin{example}
Для каждого пользователя задан некоторый набор характеристик, причем некоторые характеристики не определены. Недостающие значения характеристик определяются следующим образом: выделяется группа пользователей со схожими характеристиками, которые определены, и недостающие определяются путем изучения значений соответствующих характеристик других пользователей.
\end{example}

\subsection{Кластеризация}
Один из методов кластеризации состоит в задании метрики, с помощью которой будет проводиться разбиение. Последовательная кластеризация позволяет задать класификацию на множестве объектов. 

\subsection{Классификация}
Классификация аналогична методам распознавания при помощи шаблонов. 
$$Classifier: Logs \rightarrow Pattern\_idies$$
\end{document}
