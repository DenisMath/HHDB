\documentclass[a4paper,11pt]{article}

\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage[russian,english]{babel}
\usepackage{amssymb,upref}
\usepackage{amsmath,amsthm}
\usepackage{multicol}
\usepackage{geometry}
%\usepackage[dvips]{graphicx}
\usepackage{algorithmic}
%\usepackage[linesnumbered,boxed]{algorithm2e}
\usepackage[linesnumbered]{algorithm2e}

\setcounter{MaxMatrixCols}{10}

\newtheorem{theorem}{Теорема}[subsection]
\newtheorem{lemma}{Лемма}[subsection]
\newtheorem{corollary}{Следствие}[subsection]
\newtheorem{remark}{Замечание}[subsection]
\newtheorem{definition}{Определение}[subsection]
\newtheorem{example}{Пример}[subsection]
\newtheorem{hyp}{Гипотеза}[subsection]
\newtheorem{question}{Вопрос}[subsection]



\begin{document}

\thispagestyle{plain}

% Создание математической модели модуля Оракул.
% \section{Постановка задачи}
% Мужчина не пьет пиво - не предлагать ему пиво в контекстной рекламе.

% Пример группировки (под группировкой видимо понимается построение сложных связей):
% \begin{example}
% В близкие моменты времени зафиксирован выход девайсов A,B,C с одного IP. В этом множестве девайсов возникла (пока слабая) связь. Данная связь усиливается с каждой  фиксацией совместного выхода с одного IP.
% \end{example}
% time\_stamp - 100\%

% device\_id - 50\%

% IP - 100\%

% location - 30\%
% \section {Данные для построения}
% Нормализированная база данных логов.
% \subsection {Входные данные}
% Набор значений параметров - возраст, доход, образование и т.д.
% \subsection {Выходные данные}
% Набор IP и(или) device\_id
% \section {Параметризация модуля}
% Параметризация модуля связана с входными параметрами - возраст, доход, образование и т.д.
% \section{Плагин}
% Плагин расширения набора ip и id. На входе - набор ip и id, на выходе - расширенный набор ip и id возможно с действительным параметром. 
% \section{Комментарии}
% 1. По сути задача состоит в предсказании ip и id рекламной компании. Использование обучения модуля путем параметризации представляется проблематичным. Дело в том, что непрерывность такого модуля, как функции, вряд ли может иметь место, поскольку множество определения такой функции имеет сложную, предположительно фрактальную структуру.

% % In fact the problem is the prediction of ip and id of advertising company. Using the training of module by means of parameterization is problematic. The fact that the continuity of such a module as a function can scarcely be the case as the set of definitions of this function is complex, presumably fractal structure.

% 2. Рекламное агенство предоставляет список услуг по распространению рекламы в интернете. По логам результатов рекламной компании модуль предоставляет совет по оптимальному заказу рекламы в данном агенстве для следующей такой же рекламной компании

% % Advertising agency services list of dissemination of advertising on the Internet. According to logs of the results of the advertising company module provides  advice on the best advertising order in this agency for the next the same advertising company

% 3. Запускается небольшая рекламная компания. По ее результатам (логам) рекомендуется аудитория(список ip?) для проведения большой рекламной компании.

% \section{Группировка}
% Формализация - группировкою является функция $Group$, принимающая на входе множество логов $A$, фиксированный лог $a$ и возвращающая множество логов $B$, соответсвующих данному логу $a$.
% $$ A, B \subset Logs, a \in Logs, Group(A,a) = B$$

%  Возможна группировка по метрике $\rho$, заданной на множестве логов. При такой группировке функция $Group$ возвращает шар некоторого радиуса с центром в точке $a$.  Группировка подобного типа допускает прозрачную параметризацию. Параметр может быть привязан к радиусу возвращаемого шара. 
% $$ A, B \subset Logs, a \in Logs, \rho :Logs\times Logs \rightarrow \mathbb{R}^+$$
% $$ Group_{\rho}:2^{Logs}\times Logs \times \mathbb{R}^+ \rightarrow 2^{Logs}  $$
% $$Group_{\rho}(A,a,t) = B_{\rho}(a,t)=B$$

% \begin{question}
% Каким образом конструируется непротиворечивая метрика на логах с возможно не заполненными полями?
% \end{question}

% Пример метрической группировки:
% \begin{example}
% \end{example}

% Пример группировки по IP-связям:
% \begin{example}
% Проходим все пары девайсов(логов) во временных промежутках. Если два девайса заходили с одного IP(в двух логах одинаковый IP) в течении близкого промежутка времени, то вес между ними увеличивается на 1.

% Данная модель содержит шум. Если известна периодичность смены IP адресов, то шум можно свести к нулю. Кроме того шум можно уменьшить с помощью корректирующего множителя - для пар, более далеким по времени, вес увеличивать с меньшим коеффициентом:
% $$link(x,y) = \sum_{\{t \mid t = |x.time - y.time| \}} f(t)$$
% \end{example}

% \section{Формализация проблемы}
% Базовыми сущностями положим множество логов. Мотивация для рассмотрения именно такого базового множества, а не множества девайсов  состоит в начальной неопределенности данного множества, а, следовательно, усложнение модели формалистикой теории нечетких множеств. 

% \begin{table}[h]
% \caption{Степень определенности полей логов}
% \begin{center}
% \begin{tabular}{|c|c|c|c|}
% \hline
% time\_stamp & IP & device\_id & location \\
% \hline
% 100\% & 100\% & 50\% & 30\% \\
% \hline
% \end{tabular}
% \end{center}
% \end{table}

% Правильная же группировка множества логов позволяет в некоторых случаях получить $device\_id$  при помощи анализа косвенных данных, предоставляемых множеством логов методами коллаборативной фильтрации.

% Введем группировку на множестве логов.

% Каждый лог связан с некоторым местом( географическими координатами). Место не всегда фиксируется.

%  Зададим на множестве логов функцию со следующеей спецификацией ( LLW - Logs' Links Weight ):
% $$koord\_LLW : Logs \times Logs \rightarrow \mathbb{R}$$
% Данная функция возвращает коэффициент связи между двумя логами по близости географических координат. При высоком коэффициенте связи логи предположительно близки по координатам.
% Группировка при помощи данной функции предоставляет возможность для разбиения множества логов на кластеры, которые далее могут быть использованы  для коллаборативной фильтрации множества логов с условием близости географического положения места захвата логов. Один из возможных алгоритмов кластеризации:
% \begin{example}
% Фиксируется некоторое базовое множество логов, задающих кластеры. Например базовое множество можно определить, как множество логов с известными координатами, расположенными относительно далеко друг от друга (например близким к административным центрам ). Каждая точка(лог) относится к кластеру, который порожден базовой точкой с наибольшей связью для данной точки, в сравнении с другими базовыми точками. Должно быть определено правило соотношения точки с кластером в случае конфликтов( одинаковая коэффициент  связи с несколькими базовыми точками).
% \end{example}

%  Зададим на множестве логов функцию со следующеей спецификацией:
% $$hh\_LLW : Logs \times Logs \rightarrow \mathbb{R}$$
% Данная функция возвращает коэффициент связи между двумя логами по принадлежности к одному $household\_id$.

% \begin{remark}
% Очевидно кластеризация, полученная при помощи функции $hh\_LLW$, должна быть близка к некоторому разбиение кластеризации, полученной при помощи функции $koord\_LLW$. То есть последовательное использование данных двух функций задает некоторую 2-уровневую классификацию на множестве логов. Однако использование различных подходов при реализации данных функций может привести к существенному отклонению от данного правила.
% \end{remark}

% \section{Реализация}
% Не допустимо применять ультраметрическую модель к не полностью определенным множествам, которые могут иметь попарные непустые пересечения.
% \subsection{Построение функции $koord\_LLW$}
% Общая схема - 
% возможна группировка по четким полям при помощи системы запросов к базе данных. Определить систему запросов, позволяющих вычислить значения функции $koord\_LLW$ на области определения.

% \subsection{Построение функции $hh\_LLW$}
% Общая схема - аналогична $koord\_LLW$

% \section{Механизм рекламной компании}
% SSP отправляет пакеты логов на биржу. DSP оценивают каждый лог по релевантности логов для рекламной компании и предлагают цену за рекламу для него. Модуль предлагает карту релевантности логов для рекламной кампании. 

% \section{Используемые методы}
% \subsection{Коллаборативная фильтрация}
% \begin{example}
% Для каждого пользователя задан некоторый набор характеристик, причем некоторые характеристики не определены. Недостающие значения характеристик определяются следующим образом: выделяется группа пользователей со схожими характеристиками, которые определены, и недостающие определяются путем изучения значений соответствующих характеристик других пользователей.
% \end{example}

% \subsection{Кластеризация}
% Один из методов кластеризации состоит в задании метрики, с помощью которой будет проводиться разбиение. Последовательная кластеризация позволяет задать класификацию на множестве объектов. 

% \subsection{Классификация}
% Классификация аналогична методам распознавания при помощи шаблонов. 
% $$Classifier: Logs \rightarrow Pattern\_idies$$

% \section{Алгоритм}
% $\mathfrak{H}$ - set of households

% Будем исходить из предположения, что отображение $$f: time\times ip\rightarrow\mathfrak{H}$$ является инъективным.


% \subsection{Стабилизация координат}
% Выберем базовою величину дискретизации временной прямой(1 час, 6 часов, день и т.д.). Базовой длиной необходимо выбирать величину временного отрезка, для которого, предположительно, изменения ip не происходят. 

% Разобьем множество логов на базовые блоки - в один блок попадают логи с одинаковым ip, зафиксированные на одном базовом интервале временной прямой.

%  К каждому базовому блоку методом коллаборативной фильтрации привяжем координаты. Поскольку анализ данных показывает недостоверность части координат, полученных в логах, вычисление предположительной координаты, соответствующей блоку, происходит при помощи статистических методов. 
% \subsection{hh-инвариант}
% В базовом блоке определен hh-инвариант - вектор весов при соответствующих id.

% Для объединения 2-х блоков hh-инвариант определен, как сумма hh-инвариантов соответствующих блоков.

%  При суммировании поле с отсутствующим id добавляется со значением 0. Суммирование происходит покомпонентно, как в случае сложения векторов.
% \begin{definition}
% Инвариант базового блока определен следующим образом:
% \begin{enumerate}
%   \item Пробегаемся по множеству логов - если id присутсвует в логе, увеличиваем значение соответствующей координаты инварианта на 1. Если поле id отсутствует в инварианте - добавляем его.
%   \item Если id в логе не определено - добавляем к значениям инварианта значения, полученные в результате статистического анализа полей лога, что определены.
%   \end{enumerate}

% \end{definition}

% \subsection{Принадлежность ip-блоков к одному household}
% На множестве пар ip блоков введем коэффициент связи принадлежности к одному household, определенный, как коэффициент корреляции hh-инвариантов данных блоков.
% $$hh\_LLW (Block_1, Block_2) = \frac{\sum\limits_{X = pr_i(hh\_inv_1), Y = pr_i(hh\_inv_2)}(X-\bar{X})(Y-\bar{Y})}{\sqrt{\sum\limits_{X = pr_i(hh\_inv_1)} (X-\bar{X})^2\sum\limits_{Y = pr_i(hh\_inv_2)} (Y-\bar{Y})^2}}$$
%  Чем ближе данный коэффициент к еденице, тем больше вероятность того, что данные ip-блоки соответсвуют одному household (функция $hh\_LLW$)

% \subsection{Замена коэффициента корелляции}
% Пусть даны два вектора $\vec{v_1}$ и $\vec{v_2}$, представляющие id инварианты.
% Шаг первый - приведем данную пару к паре векторов $\vec{v_1}'$ и $\vec{v_2}'$ одинаковой длины.
% Каждый из полученных векторов нормализируем относительно вектора $(1, 1, \dots, 1)$

% Алгоритм нормализации:

% Для вектора $\vec{v} = (x_1,x_2,\dots,x_n)$ найдем минимум функции 
% $$f_{(x_1,x_2,\dots,x_n)}(\alpha)= |\alpha x_1 - 1|+\dots +|\alpha x_n - 1|$$
% Минимум данной функции будет находится в одной из точек:
% $$\{\frac{1}{x_i}| 1 \leqslant i \leqslant n \cup  x_i \neq 0\}$$
% Обозначим его как $\alpha_{min}(\vec{v})$.

% Определим коэффициент отличия двух векторов $\vec{v_1}=(x_1,\dots,x_n)$ и $\vec{v_1}=(x_1,\dots,x_n)$ следующим образом 
% $$\mathit{differenceCoeff}(\vec{v_1}, \vec{v_2} ) = \frac{\sum\limits_{i=1}^n |\alpha_{min}(\vec{v_1})x_i - \alpha_{min}(\vec{v_2})y_i| }{n}$$.

% Вектора с коэффициентом отличия близким к 0 - похожи.

\subsection{Стабилизация координат ip-блока}

На вход подается список координат с временем захвата лога, на выход - результирующая координата.
 
Общий принцип - при исследовании сходимости. Важно не общее расположение точек, а центры группировки.

Алгоритм (1-й шаг)

\begin{algorithmic}[1] 
\STATE $\rho_{min} =\{ \min \rho (x_i, x_j) |0\leqslant i,j \leqslant n \}$ 
\STATE $\rho_{max} = \{ \max \rho (x_i, x_j) | i,j \leqslant n \}$
\STATE $t=0$ 
\WHILE{ $ \rho_{max} - t*\rho_{min} > 0 $ }
 \FOR{ ( $i = 1; i \leqslant n; i++$) }
 \STATE $\alpha_t(x_i) = \mathbf{card}(\{ x_j| \rho (x_i, x_j) \leqslant \rho_{max} - t*\rho_{min}, 0\leqslant j \leqslant n \})$ 
 \ENDFOR
\STATE $t++$
\ENDWHILE

После первого шага агоритма с каждой точкой $x_i$ связана последовательность
 $$\alpha(x_i) = (\alpha_1(x_i),\alpha_2(x_i),\dots,\alpha_n(x_i)). $$

  Выберем из всех $\alpha(x_i)$ максимальный. Сравнение производится при использовании лексикографического порядка, вначале сравниваем последнии координаты. Если максимумов несколько, выбираем самый последний по времени.

\end{algorithmic}


% \subsection{Идентификация id}
% По построению идентификация id лога с данным ip происходит по hh-инварианту. 

% Вероятность id с номером i при привязке данного лога по ip к блоку Block вычисляется по следующей формуле:
% $$P(id) = \frac{pr_i(inv\_Block)}{\sum\limits_k pr_k(inv\_Block)}$$

% \newpage
%\section{Имплементация алгоритма}
% \begin{algorithmic}[1] 
% \STATE 
% \begin{verbatim}
% SELECT * FROM access_log 
%                 WHERE lat IS NOT NULL 
%                              AND long IS NOT NULL 
%                              AND homebiz-type != "business" 
%                              AND source = 'lls' 
%                  ORDER BY ip, time
% \end{verbatim}  
% \STATE  $cin \gg line$
% \STATE  $compIP \gets currentIP \gets line.ip$
% \STATE  $tempCoord \gets line.coord$
% \WHILE{ (\NOT end of data) }
% \IF{$compIP = currentIP$}
% \STATE 
% \STATE  $tempCoord \gets line.coord$
% \ELSE   
% \STATE
% \ENDIF   
% \ENDWHILE
%   %\IF {\(  \)}
% \end{algorithmic}
% \vspace{2em}

% \begin{algorithmic}[1] 
% \STATE 
% \begin{verbatim}
% SELECT * FROM access_log 
%                 WHERE lat IS NOT NULL 
%                              AND long IS NOT NULL 
%                              AND homebiz-type != "business" 
%                              AND source = 'lls' 
%                  ORDER BY ip, time
% \end{verbatim}  
% \STATE  i = 0
% %\WHILE{ (\NOT end of data) }
% \STATE \label{begin} $cin \gg line$,

% new  {\bf record}
% \STATE   $currentIP \gets  line.ip,$
 
%  $ blockCoord \gets  line.coord$ 
% \STATE  push to resultBase  {\bf record} with

%  $record.ip \gets  line.ip,$

%  $ record.coord \gets  line.coord,$

%  $ record.time\_begin \gets  line.time,$

%  $ record.group\_id \gets  i$
% \STATE $i++$ 
% \STATE $cin \gg line$
%  \IF  { $line.ip = currentIP$}  \label{ifip}
% \IF  { $line.coord  \stackrel{ CoordAccuracy}{ \simeq } currentCoord$ } 
% \STATE goto \ref{ifip}
% \ELSE   
% \STATE goto \ref{next}
% \ENDIF 
% \STATE storage.clear()
% \ELSE  
% \STATE $record.time\_end \gets previousTime $  
% \STATE goto \ref{begin}
% \ENDIF 
% \STATE \label{next} $cin \gg line$
% \IF  { $line.time  \stackrel{ TimeAccuracy}{ \simeq } previousTime$ } 
% \STATE storage.push(line)

% goto \ref{ifip}
% \ELSE   
% \STATE goto \ref{next1}
% \ENDIF 
% \STATE \label{next1} do the same with storage
% %\ENDWHILE
  
% \end{algorithmic}
% \vspace{2em}

%output table or hash output - {\sl key} ip,{\sl value} time array



% \begin{algorithm}[H]
%  \KwData{logs base}
%  \KwResult{Scheme of common grous on logs' set}
% \begin{verbatim}
% SELECT * FROM access_log 
%                 WHERE lat IS NOT NULL 
%                              AND long IS NOT NULL 
%                              AND homebiz-type != "business" 
%                              AND source = 'lls' 
%                  ORDER BY ip, time
% \end{verbatim}
 
%  \While{not end of data}{
%   $cin \gg line$\;
%   $compIP \gets currentIP \gets line.ip$\;
%   $tempCoord \gets line.coord$\;
%   \eIf{$compIP = currentIP$}{
%    Proc1\;
%    }{
%    currentIP = line.ip\;
%    Proc2\;
%   }
%  }
%  \caption{Group logs algorithm}
% \end{algorithm}



\end{document}
